function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
import { jsx as _jsx } from "react/jsx-runtime";
import { Component, forwardRef } from 'react';
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { TestBackend } from 'react-dnd-test-backend';
/**
 * Wrap a Component with a DnDContext using the TestBackend
 *
 * @param DecoratedComponent The component to decorate
 * @returns [Component, getBackend] The wrapped component and a utility method
 * to get the test backend instance.
 */ export function wrapWithTestBackend(DecoratedComponent) {
    let backend;
    const opts = {
        onCreate (be) {
            backend = be;
        }
    };
    const result = wrapWithBackend(DecoratedComponent, TestBackend, opts);
    return [
        result,
        ()=>backend
    ];
}
/**
 * Wrap a component with a DndContext providing a backend.
 *
 * @param DecoratedComponent The compoent to decorate
 * @param Backend The backend to use (default=HTML5Backend)
 * @param backendOptions The optional backend options
 */ export function wrapWithBackend(DecoratedComponent, Backend = HTML5Backend, backendOptions) {
    class TestContextWrapper extends Component {
        render() {
            const _props = this.props, { forwardedRef  } = _props, rest = _objectWithoutProperties(_props, [
                "forwardedRef"
            ]);
            return /*#__PURE__*/ _jsx(DndProvider, {
                backend: Backend,
                options: backendOptions,
                children: /*#__PURE__*/ _jsx(DecoratedComponent, _objectSpread({
                    ref: forwardedRef
                }, rest))
            });
        }
    }
    const ForwardedComponent = /*#__PURE__*/ forwardRef(function ForwardedTestContextWrapper(props, ref) {
        return /*#__PURE__*/ _jsx(TestContextWrapper, _objectSpread({}, props, {
            forwardedRef: ref
        }));
    });
    return ForwardedComponent;
}

//# sourceMappingURL=wrappers.js.map